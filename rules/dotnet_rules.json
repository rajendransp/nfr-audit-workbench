[
  {
    "id": "NFR-DOTNET-001",
    "title": "HttpClient call without CancellationToken",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\b(HttpClient|_httpClient|client)\\.(GetAsync|PostAsync|PutAsync|DeleteAsync|SendAsync)\\s*\\((?![^)]*\\bCancellationToken\\b)(?![^)]*\\bct\\b)(?![^)]*\\bstoppingToken\\b)[^)]*\\)",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/Migrations/**"],
    "rationale": "Network calls should propagate cancellation to prevent wasted compute after client disconnects."
  },
  {
    "id": "NFR-DOTNET-002",
    "title": "EF Core async query without CancellationToken",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\.(ToListAsync|FirstOrDefaultAsync|SingleOrDefaultAsync|AnyAsync|CountAsync|ExecuteUpdateAsync|ExecuteDeleteAsync)\\s*\\((?![^)]*\\bCancellationToken\\b)(?![^)]*\\bct\\b)(?![^)]*\\bstoppingToken\\b)[^)]*\\)",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/Migrations/**"],
    "rationale": "DB calls should be cancellable to avoid unnecessary work under load."
  },
  {
    "id": "NFR-DOTNET-003",
    "title": "Blocking wait in async-capable code",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S1",
    "pattern": "(\\.Result\\b(?!\\s*=)|\\.Wait\\s*\\(|GetAwaiter\\s*\\(\\)\\.GetResult\\s*\\(|\\bTask\\.Wait(All|Any)\\s*\\()",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Blocking waits can cause deadlocks and thread pool starvation."
  },
  {
    "id": "NFR-DOTNET-004",
    "title": "Thread.Sleep used",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "performance",
    "severity": "S2",
    "pattern": "\\bThread\\.Sleep\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Sleep blocks threads and harms throughput; prefer async delay with cancellation."
  },
  {
    "id": "NFR-DOTNET-005",
    "title": "new HttpClient in code path",
    "category": "scalability",
    "top_level_category": "dotnet",
    "sub_category": "loading",
    "severity": "S2",
    "pattern": "\\bnew\\s+HttpClient\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/*Tests*.cs", "**/Program.cs"],
    "rationale": "Repeated HttpClient allocation can cause socket exhaustion."
  },
  {
    "id": "NFR-DOTNET-006",
    "title": "ExecuteSqlRaw without CancellationToken",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\.ExecuteSqlRaw(Async)?\\s*\\((?![^)]*\\bCancellationToken\\b)(?![^)]*\\bct\\b)(?![^)]*\\bstoppingToken\\b)[^)]*\\)",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/Migrations/**"],
    "rationale": "Raw SQL operations should honor cancellation in services and APIs."
  },
  {
    "id": "NFR-DOTNET-007",
    "title": "High command timeout configured",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "loading",
    "severity": "S3",
    "pattern": "\\b(CommandTimeout|SetCommandTimeout)\\b[^\\n]*\\b([3-9][0-9]{2,}|[1-9][0-9]{3,})\\b",
    "include_globs": ["*.cs", "*.json", "*.config", "appsettings*.json"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Very high timeouts can mask upstream latency and propagate incidents."
  },
  {
    "id": "NFR-DOTNET-008",
    "title": "Task.Delay without CancellationToken",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\bTask\\.Delay\\s*\\((?![^)]*\\bCancellationToken\\b)(?![^)]*\\bct\\b)(?![^)]*\\bstoppingToken\\b)[^)]*\\)",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Delays in workers and retries should be cancellable for graceful shutdown."
  },
  {
    "id": "NFR-DOTNET-009",
    "title": "Unbounded Parallel.ForEach",
    "category": "scalability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\bParallel\\.ForEach\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Unbounded parallelism can overwhelm CPU, thread pool, and downstream dependencies."
  },
  {
    "id": "NFR-DOTNET-010",
    "title": "Potential N+1 query inside loop",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "loading",
    "severity": "S3",
    "pattern": "\\b(for(each)?|while)\\b[\\s\\S]{0,400}\\.(FirstOrDefaultAsync|SingleOrDefaultAsync|ToListAsync|AnyAsync|CountAsync)\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Repeated DB calls in loops can create N+1 latency and load issues."
  },
  {
    "id": "NFR-DOTNET-011",
    "title": "async void method",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S1",
    "pattern": "\\basync\\s+void\\s+[A-Za-z_][A-Za-z0-9_]*\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/*Designer.cs"],
    "rationale": "async void methods cannot be awaited and exceptions bypass normal task error handling."
  },
  {
    "id": "NFR-DOTNET-012",
    "title": "Fire-and-forget Task.Run",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "(^|\\s)_\\s*=\\s*Task\\.Run\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/*Tests*.cs"],
    "rationale": "Detached tasks can hide failures and outlive request scope resources."
  },
  {
    "id": "NFR-DOTNET-013",
    "title": "Explicit CancellationToken.None",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\bCancellationToken\\.None\\b",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/*Tests*.cs"],
    "rationale": "Hardcoding non-cancellable operations can block graceful shutdown and wasted work cancellation."
  },
  {
    "id": "NFR-DOTNET-014",
    "title": "Empty catch block",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "loading",
    "severity": "S2",
    "pattern": "\\bcatch\\s*\\([^\\)]*\\)\\s*\\{\\s*\\}",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Swallowed exceptions hide systemic failures that surface as intermittent load incidents."
  },
  {
    "id": "NFR-DOTNET-015",
    "title": "Synchronous file read in request path",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "performance",
    "severity": "S2",
    "pattern": "\\b(File\\.ReadAllText|File\\.ReadAllBytes|File\\.OpenRead)\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/*Tests*.cs"],
    "rationale": "Sync file I/O can block thread pool threads and reduce throughput."
  },
  {
    "id": "NFR-DOTNET-016",
    "title": "LINQ materialization before filtering",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "performance",
    "severity": "S3",
    "pattern": "\\.ToList\\s*\\(\\s*\\)\\s*\\.(Where|Select|OrderBy|GroupBy)\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Materializing early increases allocations and memory pressure."
  },
  {
    "id": "NFR-DOTNET-017",
    "title": "Large in-memory collection materialization",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "loading",
    "severity": "S3",
    "pattern": "\\b(_db\\w*|dbContext|context)\\b[\\s\\S]{0,240}\\.(ToArrayAsync|ToListAsync|ToArray|ToList)\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/*Tests*.cs"],
    "rationale": "Large materializations can cause memory spikes and GC churn under load."
  },
  {
    "id": "NFR-DOTNET-018",
    "title": "Missing pagination in query endpoint",
    "category": "scalability",
    "top_level_category": "dotnet",
    "sub_category": "loading",
    "severity": "S2",
    "pattern": "\\b(IQueryable<|DbSet<)[\\s\\S]{0,300}\\.(ToListAsync|ToList)\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/Migrations/**"],
    "rationale": "Unbounded result sets are a common root cause of load amplification."
  },
  {
    "id": "NFR-DOTNET-019",
    "title": "Parallel.ForEachAsync without token",
    "category": "reliability",
    "top_level_category": "dotnet",
    "sub_category": "concurrency",
    "severity": "S2",
    "pattern": "\\bParallel\\.ForEachAsync\\s*\\((?![^)]*\\bCancellationToken\\b)(?![^)]*\\bct\\b)(?![^)]*\\bstoppingToken\\b)[^)]*\\)",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**"],
    "rationale": "Parallel loops should be cancellable to avoid runaway background work."
  },
  {
    "id": "NFR-DOTNET-020",
    "title": "Read query without AsNoTracking",
    "category": "performance",
    "top_level_category": "dotnet",
    "sub_category": "performance",
    "severity": "S3",
    "pattern": "\\b_db\\w*\\.[A-Za-z0-9_]+\\b(?![\\s\\S]{0,120}AsNoTracking\\s*\\()([\\s\\S]{0,160})\\.(ToListAsync|FirstOrDefaultAsync|SingleOrDefaultAsync|AnyAsync|CountAsync)\\s*\\(",
    "include_globs": ["*.cs"],
    "exclude_globs": ["**/bin/**", "**/obj/**", "**/Migrations/**"],
    "rationale": "Tracked entities in read-only flows increase memory usage and change-tracker overhead."
  }
]
